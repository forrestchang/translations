# 重置结束

### 问题

[![](http://brettbeauregard.com/blog/wp-content/uploads/2011/03/Windup.png)](http://brettbeauregard.com/blog/wp-content/uploads/2011/03/Windup.png)  
重置结束是一个陷阱，它可能比其他任何人都吸引更多的初学者。当PID认为自己可以做一些自己做不到的事情时，就会发生这种情况。例如，Arduino上的PWM输出接受0-255之间的值。默认情况下，PID不知道这一点。如果它认为300-400-500可以工作，它将尝试使用那些期望得到所需值的值。由于实际上该值固定在255，因此它将继续尝试越来越多的数字而无所适从。

问题以怪异的滞后的形式显现出来。在上方，我们可以看到输出“超出”外部极限。降低设定点后，输出必须先减小，然后才能降至255行以下。

### 解决方案–步骤1

[![](http://brettbeauregard.com/blog/wp-content/uploads/2011/03/No-Windup.png)](http://brettbeauregard.com/blog/wp-content/uploads/2011/03/No-Windup.png)  
有几种方法可以减轻饱和，但是我选择的方法如下：告诉PID输出限制是什么。在下面的代码中，您将看到现在有一​​个SetOuputLimits函数。一旦达到任一限制，PID便停止求和（积分）。它知道无事可做。由于输出不会结束，因此当设定值下降到可以执行某项操作的范围时，我们会立即得到响应。

### 解决方案–步骤2

但是请注意，在上图中，尽管我们消除了饱和滞后，但并没有完全解决。pid认为正在发送的内容与正在发送的内容之间仍然存在差异。为什么？比例项和（在较小程度上）微分项。

即使已对积分项进行了安全钳位，P和D仍加了2美分，其结果高于输出限制。我认为这是不可接受的。如果用户调用了一个名为“ SetOutputLimits”的函数，他们必须假定这意味着“输出将保持在这些值之内”。因此，对于第2步，我们做出一个有效的假设。除了限制I项之外，我们还限制输出值，使其保持在期望的位置。

（请注意：您可能会问为什么我们需要同时钳制两个。如果我们无论如何都要进行输出，为什么还要分别钳制积分呢？如果我们所做的只是钳制输出，则积分项将回到增长的状态。尽管在升压过程中输出看起来不错，但在降压过程中我们会看到明显的滞后。）

### 代码


添加了一个新功能，允许用户指定输出限制[第52-63行]。这些限制用于钳制I项[17-18]和输出[23-24]

### 结果

[![](http://brettbeauregard.com/blog/wp-content/uploads/2011/03/No-Winup-Clamped.png)](http://brettbeauregard.com/blog/wp-content/uploads/2011/03/No-Winup-Clamped.png)  
    如我们所见，消除了缠绕。另外，输出保持在我们想要的位置。这意味着无需外部钳位输出。如果您希望它的范围是23到167，则可以将其设置为“输出限制”。  
[下一个>>](improving-the-beginner’s-pid-onoff)

